[{"title":"Dubbo源码解剖（一）架构概览与调试环境准备","date":"2018-04-26T10:26:23.000Z","path":"posts/dubbo/dubbo-src-01-overview-and-debug-environment.html","text":"Dubbo源码解剖（一）架构概览与调试环境准备居然你已经开始读源码，默认你已经有了开发基础，有些基础我们不会再说明。这一节我们预热，做一些准备工作。要盖高楼大厦，总得做备好工具，画好蓝图；随便拿几张草稿纸，拿着砖刀，就想搞高楼，那是妄想。 使用到的工具 JDK 1.8.x Maven 3.3.x Git IntelliJ IDEA Zookeeper ……工具的下载、安装、配置不是我们这里的重点，如果这些还不能自理的，请先绕道吧。 获取源码要读源码首先要获取源码 简单说明如何获取源码截止成文，Dubbo已经在apache中进行再次孵化，网站为：http://dubbo.apache.org/找到github网址: https://github.com/apache/incubator-dubbo我们可以直接： git clone https://github.com/apache/incubator-dubbo.git 或 git clone git@github.com:apache/incubator-dubbo.git 但是还是建议，先fork之后，在clone下来，应为这样我们就有一个自己的干净的阅读源码的工程，可以在fork的源码中注意些笔记和标注。 Dubboz在成文时最新的release版本为：2.6.1，我们该系列文章是基于2.6.x版本来学习。 项目克隆完后，导入到 IntelliJ IDEA 中，第一次导入需要些时间，等待maven下载依赖和编译。这里使用的2.6.x版本，项目中有以下子项目。 架构简介导入成功后我们首先运行demo验证环境是否配置正确，项目是否可以运行成功，这样才能保证我们可以阅读调试源码。运行demo之前我们先来看看官方提供的简单架构图： 对图中的组件简单的说明： 组件 角色说明 Registry 服务的注册中心，为服务提供注册与发现 Monitor 服务监视器，统计服务调用次数和调用时间等 Provider 服务提供方，暴露出服务给调用方 Consumer 服务消费者，调用远程服务或本地服务 Container 服务容器，服务运行的环境 启动顺序 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 如下图： 运行例子程序找到demo子项目里面有三个子项目，简单说明一下： dubbo-demo-api 提供服务接口项目 dubbo-demo-consumer 服务消费者 dubbo-demo-provider 服务提供者 运行Provider 我们需要启动Zookeeper 配置Provider的dubbo.properties 配置dubbo-demo-provider.xml 找到DemoProvider，run or debug如果顺利，你最终会在console看到：“Dubbo service server started!”123456789[27/04/18 09:49:53:053 CST] main-SendThread() INFO zookeeper.ClientCnxn: Opening socket connection to server /127.0.0.1:2181[27/04/18 09:49:53:053 CST] main-SendThread(localhost:2181) INFO zookeeper.ClientCnxn: Socket connection established to localhost/127.0.0.1:2181, initiating session[27/04/18 09:49:53:053 CST] main-SendThread(localhost:2181) INFO zookeeper.ClientCnxn: Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x100000078590005, negotiated timeout = 30000[27/04/18 09:49:53:053 CST] main-EventThread INFO zkclient.ZkClient: zookeeper state changed (SyncConnected)[27/04/18 09:49:53:053 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Register: dubbo://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, dubbo version: 2.0.0, current host: 127.0.0.1[27/04/18 09:49:53:053 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Subscribe: provider://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, dubbo version: 2.0.0, current host: 127.0.0.1[27/04/18 09:49:53:053 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Notify urls for subscribe url provider://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, urls: [empty://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543], dubbo version: 2.0.0, current host: 127.0.0.1[27/04/18 09:49:53:053 CST] main INFO container.Main: [DUBBO] Dubbo SpringContainer started!, dubbo version: 2.0.0, current host: 127.0.0.1[2018-04-27 09:49:53] Dubbo service server started! 启动完Provider，接下来启动Consumer 配置Consumer的dubbo.properties 配置dubbo-demo-consumer.xml 找到DemoConsumer，run or debug如果顺利，你最终会在console看到： Consumer端的console会打印出：123456789101112131415161718[27/04/18 09:54:05:005 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Register: consumer://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=consumers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:05:005 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Subscribe: consumer://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=providers,configurators,routers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:05:005 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Notify urls for subscribe url consumer://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=providers,configurators,routers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, urls: [dubbo://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, empty://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, empty://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=routers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782], dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:05:005 CST] main INFO transport.AbstractClient: [DUBBO] Successed connect to server /192.168.10.44:20880 from NettyClient 192.168.10.44 using dubbo version 2.0.0, channel is NettyChannel [channel=[id: 0x409bf450, /192.168.10.44:64211 =&gt; /192.168.10.44:20880]], dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:05:005 CST] main INFO transport.AbstractClient: [DUBBO] Start NettyClient Luxx.local/192.168.10.44 connect to the server /192.168.10.44:20880, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:05:005 CST] main INFO config.AbstractConfig: [DUBBO] Refer dubbo service com.alibaba.dubbo.demo.DemoService from url zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?anyhost=true&amp;application=demo-consumer&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;monitor=dubbo%3A%2F%2F127.0.0.1%3A2181%2Fcom.alibaba.dubbo.registry.RegistryService%3Fapplication%3Ddemo-consumer%26dubbo%3D2.0.0%26pid%3D35044%26protocol%3Dregistry%26refer%3Ddubbo%253D2.0.0%2526interface%253Dcom.alibaba.dubbo.monitor.MonitorService%2526pid%253D35044%2526timestamp%253D1524794045101%26registry%3Dzookeeper%26timestamp%3D1524794045063&amp;owner=william&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:06:006 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Register: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=consumers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:06:006 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Subscribe: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:06:006 CST] main INFO zookeeper.ZookeeperRegistry: [DUBBO] Notify urls for subscribe url consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, urls: [empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=configurators&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101], dubbo version: 2.0.0, current host: 192.168.10.44[09:54:06] Hello world 0, response form provider: 192.168.10.44:20880[09:54:08] Hello world 1, response form provider: 192.168.10.44:20880[09:54:10] Hello world 2, response form provider: 192.168.10.44:20880[09:54:12] Hello world 3, response form provider: 192.168.10.44:20880[09:54:14] Hello world 4, response form provider: 192.168.10.44:20880[09:54:16] Hello world 5, response form provider: 192.168.10.44:20880[09:54:18] Hello world 6, response form provider: 192.168.10.44:20880[09:54:20] Hello world 7, response form provider: 192.168.10.44:20880[09:54:22] Hello world 8, response form provider: 192.168.10.44:20880 Provider端的console会打印出：123456789101112[09:54:06] Hello world 0, request from consumer: /192.168.10.44:64211[27/04/18 09:54:06:006 CST] DubboServerHandler-192.168.10.44:20880-thread-2 INFO zookeeper.ZookeeperRegistry: [DUBBO] Register: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=consumers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:06:006 CST] DubboServerHandler-192.168.10.44:20880-thread-2 INFO zookeeper.ZookeeperRegistry: [DUBBO] Subscribe: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, dubbo version: 2.0.0, current host: 192.168.10.44[27/04/18 09:54:06:006 CST] DubboServerHandler-192.168.10.44:20880-thread-2 INFO zookeeper.ZookeeperRegistry: [DUBBO] Notify urls for subscribe url consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, urls: [empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=configurators&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056], dubbo version: 2.0.0, current host: 192.168.10.44[09:54:08] Hello world 1, request from consumer: /192.168.10.44:64211[09:54:10] Hello world 2, request from consumer: /192.168.10.44:64211[09:54:12] Hello world 3, request from consumer: /192.168.10.44:64211[09:54:14] Hello world 4, request from consumer: /192.168.10.44:64211[09:54:16] Hello world 5, request from consumer: /192.168.10.44:64211[09:54:18] Hello world 6, request from consumer: /192.168.10.44:64211[09:54:20] Hello world 7, request from consumer: /192.168.10.44:64211[09:54:22] Hello world 8, request from consumer: /192.168.10.44:64211 至此，我们已经配置好dubbo的调试环境。笔者毕竟能力有限，难免有疏漏，如果，大家发现文章有何错误，请不吝赐教。谢谢！","excerpt":"","categories":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/categories/Java/"},{"name":"Dubbo","slug":"Java/Dubbo","permalink":"http://seekheap.com/categories/Java/Dubbo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/tags/Java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"http://seekheap.com/tags/Dubbo/"},{"name":"RPC","slug":"RPC","permalink":"http://seekheap.com/tags/RPC/"}]},{"title":"Java Concurrency Perspective Overview (一) </br> Java 并发透视之初窥探（一）","date":"2017-08-17T04:07:01.000Z","path":"posts/java/concurrency/java-concurrency-perspective-001-overview.html","text":"Java 并发透视之初窥探（一）概述Java是一种支持多线程编程的语言，意味着，我们可以使用Java开发多线程程序。一个多线程程序包含两个或多个可以同时运行的部件，每个部件可以同时处理不同的任务，特别是当计算机有多个CPU时，可以有效地利用可用资源。多任务是指多个进程共享共同的处理资源，如CPU。多线程将多任务的概念扩展到可以将单个应用程序中的特定操作细分为单个线程的应用程序。每个线程可以并行运行。OS不仅在不同的应用程序之间划分处理时间，而且在应用程序中的每个线程之间划分处理时间。多线程使您能够以同一程序同时进行多个活动的方式进行写入。 线程的生命周期线程生命周期经历了几个阶段：线程诞生，启动，运行，阻塞，死亡。下图简要显示了一个线程的完整生命周期。 +-------------+ start() \\=-------------=/ new Thread()--&gt;| New |------------&gt;\\ Runnable /&lt;---------+ +------+------+ \\-----+-----/ | | | | | |run() | v End of v | +------+------+ execution /------+-------\\ | End&lt;--\\ Dead /&lt;------------| Running | | -------+------- \\------+-------/ | Release Block ^ | | | |sleep(), wait() | | =-------------= | | +------| Blocked |&lt;-----+ | =------+------= | | | | | +-------------------------------+ Life cycle of a Thread ----------------------------- 以下是生命周期的各个阶段简述： 新的（New） - 新线程在新的状态下开始其生命周期。直到程序启动线程为止，它保持在这种状态。它也被称为新生线程。 可运行的（Runnable） - 新诞生的线程启动后，该线程可以运行。该状态的线程被认为正在执行其任务。但是，可能还未正式运行，可能在等待资源，如：CPU。 运行中的（Running） - 新诞生的线程启动后，如果，所有的准备条件已经满足，该线程会从准备运行状态进入运行状态，执行任务。 等待（Waiting） - 有时线程会转换到等待状态，而线程等待另一个线程执行任务。只有当另一个线程发信号通知等待线程才能继续执行时，线程才转回到可运行状态。 定时等待（Timed Waiting） - 可运行的线程可以在指定的时间间隔内进入定时等待状态。当该时间间隔到期或发生等待的事件时，此状态的线程将转换回可运行状态。 终止（Dead） - 可执行线程在完成任务或以其他方式终止时进入终止状态。 线程的优先级每一个线程都有一个优先级，可以帮助操作系统确定安排线程的顺序。 Java线程优先级在MIN_PRIORITY（常量为1）和MAX_PRIORITY（常量为10）之间的范围内。默认情况下，每个线程都被赋予优先级NORM_PRIORITY（常量为5）。 具有较高优先级的线程对于一个程序来说更重要，应该在低优先级线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，并且依赖于平台。 创建自己的第一个线程Java主要可以通过两种方式创建多线程的程序： 1.通过实现Runnable接口创建一个线程（推荐使用）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class RunnableDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ RunnableDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestRunnable &#123; // 启动两个线程测试 public static void main(String args[]) &#123; RunnableDemo r1 = new RunnableDemo(\"Thread-1\"); r1.start(); RunnableDemo r2 = new RunnableDemo(\"Thread-2\"); r2.start(); &#125;&#125; 2.通过继承Thread类创建一个线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 继承Thread类，创建线程 * * @author Asion * @since 2017/03/24 */class ThreadDemo extends Thread &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; ThreadDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 重写父类的start()方法 * 谨慎重写父类的start()方法 */ @Override public void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用父类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestThread &#123; // 启动两个线程测试 public static void main(String args[]) &#123; ThreadDemo t1 = new ThreadDemo(\"Thread-1\"); t1.start(); ThreadDemo t2 = new ThreadDemo(\"Thread-2\"); t2.start(); &#125;&#125; 我们来简单分析一下多线程的程序 首先，我们的RunnableDemo实现的Runnable接口，那必须重写run()方法，run()就是线程running运行的方法，是线程体。 当new一个Thread实例，传入我们的RunnableDemo实例，这时线程生命周期处在新建（new）阶段； 然后，当调用Thread实例的start()方法时，说明线程已经准备就绪，转到了就绪（Runnable）状态； 如果此时，分配到了CPU，调用了run()方法开始执行，就转到运行（Running）状态； 当run()方法运行结束，线程就结束；或者run()方法中异常导致线程结束退出。 通过这一小节我们，我们了解java线程的创建和启动。下一节我们来看看java多线程的主要操作。","excerpt":"","categories":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/categories/Java/"},{"name":"Concurrency","slug":"Java/Concurrency","permalink":"http://seekheap.com/categories/Java/Concurrency/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/tags/Java/"},{"name":"Concurrency","slug":"Concurrency","permalink":"http://seekheap.com/tags/Concurrency/"}]},{"title":"三言两语@Java 数组","date":"2017-03-21T14:17:16.000Z","path":"posts/java/core/java-array-and-memory.html","text":"数组在Java中，数组存储可以存储对象的原始值（int，char，long，…）或引用类型（也可称为指针）。使用“new”创建对象时，会在Heap中分配一个内存空间并返回一个引用。对于数组也是如此，因为数组是Java中的对象。 1. 单维数组 12int a1[ ] = new int[3];int a2[ ] = new int[ ]&#123;3, 6, 7, 4, 9&#125;; int [] a1 只是3个整数数组的引用。如果创建一个包含10个整数的数组，则它是相同的 - 分配一个数组并返回一个引用。 2. 二维数组 二维数组怎么样？实际上，我们只能在Java中使用一维数组。二维数组只是一维数组的数组。 1234int[ ][ ] arr = new int[3][ ];arr[0] = new int[3];arr[1] = new int[5];arr[2] = new int[4]; 多维数组与二维数组是同样的道理。 3. 数组位于Java内存中的哪个位置？ 数组也是Java中的对象，因此对象在内存中如何存储，数组也是一样的形式，只是数组分配了一个连续的内存，用来存储相同类型数据。 我们知道JVM运行时数据区包括：Heap（堆），JVM Stacks（JVM栈），Native Method Stacks（本地方法栈）等。对于如下的简单示例，让我们看看数组与对象及其引用的存储位置。 123456789101112131415161718192021222324252627class A &#123; int x; int y;&#125; ... public void m1() &#123; int i = 0; m2();&#125; public void m2() &#123; A a2 = new A(); m3();&#125;public void m3() &#123; int a3[] = new int[]&#123;3, 6, 7, 4, 9&#125;; m4();&#125;public void m4() &#123; A[] a4[] = new A[3];&#125;... 通过上面的声明，如果，我们调用 m1() 看看会发生什么： 当调用m1时，新栈帧（Frame-1）被推入栈，而局部变量i也在Frame-1中创建。 然后在m1内调用m2，将另一个新栈帧（Frame-2）推入栈。在m2中，在堆中创建类A的对象，并将引用变量放在 Frame-2 帧中。此时，堆栈和堆如下所示： 方法 m2 继续调用 m3，将另一个新栈帧（Frame-3）push 入栈，方法中，创建了 int[ ] 数组，并将引用 a3 返回放在 Frame-3 帧中。 方法 m3 继续调用 m4，新栈帧（Frame-3）推入栈，方法 m4 中，创建了存储 A 类型的数组：A[ ] a4 = new A[3]; 数组长度为：3；并将引用 a4 返回放在 Frame-4 帧中。此时，堆栈和堆如下所示： 数组的处理方式与对象相同，因此数组在内存中的位置是没有太大的区别。三言两语，简单的说了一说数组，不知读者是否有所收获，欢迎留言！ 笔者毕竟能力有限，难免有疏漏，如果，大家发现文章有何错误，请不吝赐教。谢谢！","excerpt":"","categories":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/categories/Java/"},{"name":"Core","slug":"Java/Core","permalink":"http://seekheap.com/categories/Java/Core/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/tags/Java/"},{"name":"Array","slug":"Array","permalink":"http://seekheap.com/tags/Array/"}]},{"title":"Java 架构师知识图谱","date":"2017-03-21T13:48:57.000Z","path":"posts/java/java-leaning-road.html","text":"Java 架构师学习之路 从菜佳娃–&gt;佳娃假购师 分布式架构师知识图谱","excerpt":"","categories":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/categories/Java/"},{"name":"Architecture","slug":"Java/Architecture","permalink":"http://seekheap.com/categories/Java/Architecture/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://seekheap.com/tags/Java/"},{"name":"Architecture","slug":"Architecture","permalink":"http://seekheap.com/tags/Architecture/"}]},{"title":"Git版本控制与Git Flow工作流程","date":"2016-08-26T12:33:25.000Z","path":"posts/scm/git-flow.html","text":"GIT版本控制与工作流程修订历史记录 日期：2016-08-26版本：0.1修订人：Asion Lu备注：修订版 引言编写的目的 通过规范化的流程，使得产品、开发与测试等各个部门更高效的协同工作。 通过规范化的流程使得产品高效稳定运行。 背景在多组员，多项目等环境进行协同工作时，如果没有统一规范、统一流程，则会导致额外的工作量，甚至会做无用功。所以要减少版本冲突，减轻不必要的工作，就需要规范化的工作流程。 总则 统一使用Git作为版本控制的主要工具。 统一使用GitFlow流程管理控制版本。 提交的准则 除了源码相关的东西之外，其他build产生的东西（如：maven的target文件夹，.idea文件夹等），均不能提交进入源码仓库，添加到.gitignore文件中忽略掉。 撰写规范的提交说明。一份好的提交说明可以帮助协作者更轻松更有效地配合工作。 要严格按照我们指定的流程切换到指定分支，开发相应的功能。 分支简述我们使用的分支流程： 天蓝色圆点所在的线为我们源码的主线（master）。 天蓝色方形指向的节点就是每一个发布版本的标签（tag）。 紫色圆点所在的线为主要分支线（develop）。 橙色圆点所在的线为新功能开发分支线（feature）。 绿色圆点所在的线为新版本发布线（release）。 红色圆点所在的线为发布版本bug修复线（hotfix）。 主分支说明代替原来的单个主线（master），我们使用两个分支来记录源码轨迹： 原来的master分支用来记录官方发布轨迹； 新的develop分支是一个集成分支，用来记录开发新功能的轨迹。除了master主线和develop主分支线，其他的分支都是临时的分支，有一定的生命周期的，其余的工作流程分支都是围绕这两个分支之间的区别进行的。 其他分支说明 新功能分支（Feature Branches） 每一个新的功能都应该创建一个独立的分支，从develop分支中派生出来。当功能完成后，要合并（merged）回develop分支，合并后它的生命周期就结束。新功能分支不会与master分支有直接的交汇。如图： 注意：对于所有意图和目的，新功能分支会合并到develop分支。但是，这个Gitflow工作流不会在此结束。 发布分支（Release Branches） 一旦开发的功能已经满足发布条件（或预定发布日期接近），应该合并所有满足发布条件的新功能分支到develop分支中，然后，开出一个发布分支（Release），开始准备一个发布版本。在这个分支上，不能再添加新的功能，只有bug修复和该版本为导向的任务。一旦到了发布日期，Release就要合并回master发布，并且，打出版本标签。另外，还需要合并回develop分支。 使用一个专门的分支来准备发布版本，使得一个团队能对当前版本进行抛光，而另一个团队继续为下一个版本的功能做准备。它还创造了良好定义的发展阶段（例如，很容易说，“本周我们正在准备4.0版”，而且真实地看到它在库中的结构）。 维护分支（Maintenance Branches） 维护分支也就是线上bug修复分支，使用来快速修复生产环境的紧急问题。 这个分支是唯一一个开放过程中直接从master分支派生来的分支。快速的修复问题后，它应该被合并回master和develop（或者当前发布分支），然后，master分支需要打一个版本标签。 一个专门的错误修复开发线，可以让团队在不等待下一个发布周期，导致中断工作流程情况下解决问题。可以将维护分支当做主要的问题修复分支，与master并行。 命名约定 主分支名称：master 主开发分支名称：develop 标签（tag）名称：v*.RELEASE，其中”*“ 为版本号，“RELEASE”大写，如：v1.0.0.RELEASE 新功能开发分支名称：feature-* or feature/*，其中“*” 为新功能简述，如：feature-item-activity-list 发布分支名称：release-* or release/*，其中* 为版本号，“release”小写，如：release-1.0.0 master的bug修复分支名称：hotfix-* or hotfix/* ，其中* 为bug简述，如：hotfix/item-update-bug工作流程下面具体演示如何使用工作流来管理版本发布周期。假设我们已经存在或创建了一个源码中央存储仓库。 工作流的基础创建develop分支 项目负责人在本地master基础上创建一个develop分支，然后，推送到服务器； 12git branch developgit push -u origin develop 其他开发人员，需要克隆develop中央仓库的源码，创建一个develop的轨迹版本；如果，已经克隆过该项目，则，不需要执行以下第一条命令。 12git clone git@bitbucket.org:ytx-dev/ytx-demo.gitgit checkout -b develop origin/develop develop这个分支将包含项目的完整历史记录，而master将包含缩略版本。 假设开始以下所有的流程之前，都已经创建好develop分支。 新功能开发流程 新建feature分支 基于develop分支创建新功能分支： 1git checkout -b feature/demo develop 推送到远程仓库，共享： 1git push 所有开发此新功能的人员，都在此分支上开发提交代码。 123git statusgit add &lt;some-file&gt;git commit -m \"Add some-file.\" 完成新功能开发（合并feature分支到develop） 当确定新功能开发完成，且联调测试通过，并且新功能负责人已经得到合并feature分支到develop分支的允许；这样才能合并feature分支到develop。 12345git pull origin develop git checkout developgit merge feature/demogit pushgit branch -d feature/demo 第一条命令是确保在合并新功能之前，develop分支是最新的。 注意： 新功能分支，永远不要直接合并到master分支。 合并可能会有冲突，应该谨慎处理冲突。 在测试环境发布develop分支代码（提交测试） 线上版本发布流程 从develop中创建准备发布的release分支 当主测试流程完成，源码已经趋近于稳定状态，应该准备一个发布版本，确立版本号： 1git checkout -b release-0.1.0 develop 推送到远程仓库共享： 1git push 这个分支是清理准备发布、 整体回归测试、 更新文档，和做其他任何系统即将发布的事情。 继续抛光改bug release分支合并到master发布 一旦已经满足发布条件（或已经到了预定发布日期），应该把release分支合并到master分支和develop分支中，然后，使用master发布新版本。合并release分支到develop分支是很重要的，要让release上修改的东西能在后续的开发分支中生效。 123git checkout mastergit merge release-0.1.0git push release分支合并到develop 1234 git checkout developgit merge release-0.1.0git pushgit branch -d release-0.1.0 打标签 Release分支在功能开发分支（develop）和公共发布版（master）中，充当一个缓冲的作用。每当有源码合并到master中的时候，应该在master上打一个标签，以便后续跟踪查阅。 12git tag -a 0.1.0.RELEASE -m \"Initial public release\" mastergit push --tags 线上Bug修复流程当终端用户，反馈系统有bug时，为了处理bug，需要从master中创建出保养分支；等到bug修复完成，需要合并回master： 创建hotfix分支 1git checkout -b issue-#001 master 修改bug Fix the bug 完成修复，合并到master发布 123git checkout mastergit merge issue-#001git push 打标签 12git tag -a 0.1.1.RELEASE -m \"Initial public release\" mastergit push --tags 合并到develop 123git checkout developgit merge issue-#001git push 其他附录参考资料 git-book what-is-version-control gitflow-workflow","excerpt":"","categories":[{"name":"VCS","slug":"VCS","permalink":"http://seekheap.com/categories/VCS/"},{"name":"Git","slug":"VCS/Git","permalink":"http://seekheap.com/categories/VCS/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://seekheap.com/tags/Git/"},{"name":"Git-flow","slug":"Git-flow","permalink":"http://seekheap.com/tags/Git-flow/"},{"name":"VCS","slug":"VCS","permalink":"http://seekheap.com/tags/VCS/"},{"name":"SCM","slug":"SCM","permalink":"http://seekheap.com/tags/SCM/"}]}]