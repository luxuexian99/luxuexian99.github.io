<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vincent Lu&#39;s Blog</title>
  
  <subtitle>A little bit.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://seekheap.com/"/>
  <updated>2018-12-19T09:57:30.079Z</updated>
  <id>http://seekheap.com/</id>
  
  <author>
    <name>Vincent Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo源码解剖（一）架构概览与调试环境准备</title>
    <link href="http://seekheap.com/posts/dubbo/dubbo-src-01-overview-and-debug-environment.html"/>
    <id>http://seekheap.com/posts/dubbo/dubbo-src-01-overview-and-debug-environment.html</id>
    <published>2018-04-26T10:26:23.000Z</published>
    <updated>2018-12-19T09:57:30.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo源码解剖（一）架构概览与调试环境准备"><a href="#Dubbo源码解剖（一）架构概览与调试环境准备" class="headerlink" title="Dubbo源码解剖（一）架构概览与调试环境准备"></a>Dubbo源码解剖（一）架构概览与调试环境准备</h1><p>居然你已经开始读源码，默认你已经有了开发基础，有些基础我们不会再说明。这一节我们预热，做一些准备工作。要盖高楼大厦，总得做备好工具，画好蓝图；随便拿几张草稿纸，拿着砖刀，就想搞高楼，那是妄想。</p><h3 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h3><ul><li>JDK 1.8.x</li><li>Maven 3.3.x</li><li>Git</li><li>IntelliJ IDEA</li><li>Zookeeper</li><li>……<br>工具的下载、安装、配置不是我们这里的重点，如果这些还不能自理的，请先绕道吧。</li></ul><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p>要读源码首先要获取源码</p><ul><li><p>简单说明如何获取源码<br>截止成文，Dubbo已经在apache中进行再次孵化，网站为：<a href="http://dubbo.apache.org/" target="_blank" rel="external">http://dubbo.apache.org/</a><br>找到github网址: <a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="external">https://github.com/apache/incubator-dubbo</a><br>我们可以直接：</p><p>  git clone <a href="https://github.com/apache/incubator-dubbo.git" target="_blank" rel="external">https://github.com/apache/incubator-dubbo.git</a><br>  或<br>  git clone <a href="mailto:git@github.com" target="_blank" rel="external">git@github.com</a>:apache/incubator-dubbo.git</p></li><li><p>但是还是建议，先fork之后，在clone下来，应为这样我们就有一个自己的干净的阅读源码的工程，可以在fork的源码中注意些笔记和标注。</p></li></ul><p>Dubboz在成文时最新的release版本为：2.6.1，我们该系列文章是基于2.6.x版本来学习。</p><p>项目克隆完后，导入到 IntelliJ IDEA 中，第一次导入需要些时间，等待maven下载依赖和编译。<br>这里使用的2.6.x版本，项目中有以下子项目。</p><h3 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h3><p>导入成功后我们首先运行demo验证环境是否配置正确，项目是否可以运行成功，这样才能保证我们可以阅读调试源码。<br>运行demo之前我们先来看看官方提供的简单架构图：<br><img src="http://seekheap.com/assets/img/dubbo/dubbo-architecture.png" alt="dubbo-architecture"></p><p>对图中的组件简单的说明：</p><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">角色说明</th></tr></thead><tbody><tr><td style="text-align:left">Registry</td><td style="text-align:left">服务的注册中心，为服务提供注册与发现</td></tr><tr><td style="text-align:left">Monitor</td><td style="text-align:left">服务监视器，统计服务调用次数和调用时间等</td></tr><tr><td style="text-align:left">Provider</td><td style="text-align:left">服务提供方，暴露出服务给调用方</td></tr><tr><td style="text-align:left">Consumer</td><td style="text-align:left">服务消费者，调用远程服务或本地服务</td></tr><tr><td style="text-align:left">Container</td><td style="text-align:left">服务容器，服务运行的环境</td></tr></tbody></table><p>启动顺序</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p>如下图：<br><img src="http://seekheap.com/assets/img/dubbo/dubbo-init.png" alt="start sequence"></p><h3 id="运行例子程序"><a href="#运行例子程序" class="headerlink" title="运行例子程序"></a>运行例子程序</h3><h4 id="找到demo子项目"><a href="#找到demo子项目" class="headerlink" title="找到demo子项目"></a>找到demo子项目</h4><p><img src="../../assets/img/dubbo/dubbo-demo.png" alt="dubbo-demo"><br>里面有三个子项目，简单说明一下：</p><ul><li>dubbo-demo-api 提供服务接口项目</li><li>dubbo-demo-consumer 服务消费者</li><li>dubbo-demo-provider 服务提供者</li></ul><h4 id="运行Provider"><a href="#运行Provider" class="headerlink" title="运行Provider"></a>运行Provider</h4><ol><li>我们需要启动Zookeeper</li><li>配置Provider的dubbo.properties<br><img src="../../assets/img/dubbo/dubbo-demo-provider-properties.png" alt="dubbo-demo-provider-properties"></li><li>配置dubbo-demo-provider.xml<br><img src="../../assets/img/dubbo/dubbo-demo-provider-xml.png" alt="dubbo-demo-provider-xml"></li><li>找到DemoProvider，run or debug<br>如果顺利，你最终会在console看到：“Dubbo service server started!”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[27/04/18 09:49:53:053 CST] main-SendThread()  INFO zookeeper.ClientCnxn: Opening socket connection to server /127.0.0.1:2181</span><br><span class="line">[27/04/18 09:49:53:053 CST] main-SendThread(localhost:2181)  INFO zookeeper.ClientCnxn: Socket connection established to localhost/127.0.0.1:2181, initiating session</span><br><span class="line">[27/04/18 09:49:53:053 CST] main-SendThread(localhost:2181)  INFO zookeeper.ClientCnxn: Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x100000078590005, negotiated timeout = 30000</span><br><span class="line">[27/04/18 09:49:53:053 CST] main-EventThread  INFO zkclient.ZkClient: zookeeper state changed (SyncConnected)</span><br><span class="line">[27/04/18 09:49:53:053 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: dubbo://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, dubbo version: 2.0.0, current host: 127.0.0.1</span><br><span class="line">[27/04/18 09:49:53:053 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Subscribe: provider://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, dubbo version: 2.0.0, current host: 127.0.0.1</span><br><span class="line">[27/04/18 09:49:53:053 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Notify urls for subscribe url provider://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, urls: [empty://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543], dubbo version: 2.0.0, current host: 127.0.0.1</span><br><span class="line">[27/04/18 09:49:53:053 CST] main  INFO container.Main:  [DUBBO] Dubbo SpringContainer started!, dubbo version: 2.0.0, current host: 127.0.0.1</span><br><span class="line">[2018-04-27 09:49:53] Dubbo service server started!</span><br></pre></td></tr></table></figure></li></ol><h4 id="启动完Provider，接下来启动Consumer"><a href="#启动完Provider，接下来启动Consumer" class="headerlink" title="启动完Provider，接下来启动Consumer"></a>启动完Provider，接下来启动Consumer</h4><ol><li>配置Consumer的dubbo.properties<br><img src="../../assets/img/dubbo/dubbo-demo-consumer-properties.png" alt="dubbo-demo-consumer-properties"></li><li>配置dubbo-demo-consumer.xml<br><img src="../../assets/img/dubbo/dubbo-demo-consumer-xml.png" alt="dubbo-demo-consumer-xml"></li><li>找到DemoConsumer，run or debug<br>如果顺利，你最终会在console看到：</li></ol><p>Consumer端的console会打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[27/04/18 09:54:05:005 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: consumer://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=consumers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:05:005 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Subscribe: consumer://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=providers,configurators,routers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:05:005 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Notify urls for subscribe url consumer://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=providers,configurators,routers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, urls: [dubbo://192.168.10.44:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=34925&amp;side=provider&amp;timestamp=1524793792543, empty://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, empty://192.168.10.44/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=routers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782], dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:05:005 CST] main  INFO transport.AbstractClient:  [DUBBO] Successed connect to server /192.168.10.44:20880 from NettyClient 192.168.10.44 using dubbo version 2.0.0, channel is NettyChannel [channel=[id: 0x409bf450, /192.168.10.44:64211 =&gt; /192.168.10.44:20880]], dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:05:005 CST] main  INFO transport.AbstractClient:  [DUBBO] Start NettyClient Luxx.local/192.168.10.44 connect to the server /192.168.10.44:20880, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:05:005 CST] main  INFO config.AbstractConfig:  [DUBBO] Refer dubbo service com.alibaba.dubbo.demo.DemoService from url zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?anyhost=true&amp;application=demo-consumer&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;monitor=dubbo%3A%2F%2F127.0.0.1%3A2181%2Fcom.alibaba.dubbo.registry.RegistryService%3Fapplication%3Ddemo-consumer%26dubbo%3D2.0.0%26pid%3D35044%26protocol%3Dregistry%26refer%3Ddubbo%253D2.0.0%2526interface%253Dcom.alibaba.dubbo.monitor.MonitorService%2526pid%253D35044%2526timestamp%253D1524794045101%26registry%3Dzookeeper%26timestamp%3D1524794045063&amp;owner=william&amp;pid=35044&amp;side=consumer&amp;timestamp=1524794044782, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:06:006 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=consumers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:06:006 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Subscribe: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:06:006 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Notify urls for subscribe url consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, urls: [empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=configurators&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=35044&amp;timestamp=1524794045101], dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[09:54:06] Hello world 0, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:08] Hello world 1, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:10] Hello world 2, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:12] Hello world 3, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:14] Hello world 4, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:16] Hello world 5, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:18] Hello world 6, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:20] Hello world 7, response form provider: 192.168.10.44:20880</span><br><span class="line">[09:54:22] Hello world 8, response form provider: 192.168.10.44:20880</span><br></pre></td></tr></table></figure></p><p>Provider端的console会打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[09:54:06] Hello world 0, request from consumer: /192.168.10.44:64211</span><br><span class="line">[27/04/18 09:54:06:006 CST] DubboServerHandler-192.168.10.44:20880-thread-2  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=consumers&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:06:006 CST] DubboServerHandler-192.168.10.44:20880-thread-2  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Subscribe: consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[27/04/18 09:54:06:006 CST] DubboServerHandler-192.168.10.44:20880-thread-2  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Notify urls for subscribe url consumer://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers,configurators,routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, urls: [empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=providers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=configurators&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056, empty://192.168.10.44/com.alibaba.dubbo.monitor.MonitorService?category=routers&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.monitor.MonitorService&amp;pid=34925&amp;timestamp=1524793793056], dubbo version: 2.0.0, current host: 192.168.10.44</span><br><span class="line">[09:54:08] Hello world 1, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:10] Hello world 2, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:12] Hello world 3, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:14] Hello world 4, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:16] Hello world 5, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:18] Hello world 6, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:20] Hello world 7, request from consumer: /192.168.10.44:64211</span><br><span class="line">[09:54:22] Hello world 8, request from consumer: /192.168.10.44:64211</span><br></pre></td></tr></table></figure></p><p>至此，我们已经配置好dubbo的调试环境。<br>笔者毕竟能力有限，难免有疏漏，如果，大家发现文章有何错误，请不吝赐教。谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dubbo源码解剖（一）架构概览与调试环境准备&quot;&gt;&lt;a href=&quot;#Dubbo源码解剖（一）架构概览与调试环境准备&quot; class=&quot;headerlink&quot; title=&quot;Dubbo源码解剖（一）架构概览与调试环境准备&quot;&gt;&lt;/a&gt;Dubbo源码解剖（一）架构概览与
      
    
    </summary>
    
      <category term="Java" scheme="http://seekheap.com/categories/Java/"/>
    
      <category term="Dubbo" scheme="http://seekheap.com/categories/Java/Dubbo/"/>
    
    
      <category term="Java" scheme="http://seekheap.com/tags/Java/"/>
    
      <category term="Dubbo" scheme="http://seekheap.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="http://seekheap.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency Perspective Overview (一) &lt;/br&gt; Java 并发透视之初窥探（一）</title>
    <link href="http://seekheap.com/posts/java/concurrency/java-concurrency-perspective-001-overview.html"/>
    <id>http://seekheap.com/posts/java/concurrency/java-concurrency-perspective-001-overview.html</id>
    <published>2017-08-17T04:07:01.000Z</published>
    <updated>2018-07-25T11:00:51.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-并发透视之初窥探（一）"><a href="#Java-并发透视之初窥探（一）" class="headerlink" title="Java 并发透视之初窥探（一）"></a>Java 并发透视之初窥探（一）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java是一种支持多线程编程的语言，意味着，我们可以使用Java开发多线程程序。一个多线程程序包含两个或多个可以同时运行的部件，每个部件可以同时处理不同的任务，特别是当计算机有多个CPU时，可以有效地利用可用资源。<br>多任务是指多个进程共享共同的处理资源，如CPU。多线程将多任务的概念扩展到可以将单个应用程序中的特定操作细分为单个线程的应用程序。每个线程可以并行运行。OS不仅在不同的应用程序之间划分处理时间，而且在应用程序中的每个线程之间划分处理时间。<br>多线程使您能够以同一程序同时进行多个活动的方式进行写入。</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程生命周期经历了几个阶段：线程诞生，启动，运行，阻塞，死亡。下图简要显示了一个线程的完整生命周期。</p><hr><pre><code>               +-------------+   start()  \=-------------=/new Thread()--&gt;|     New     |------------&gt;\  Runnable   /&lt;---------+               +------+------+              \-----+-----/           |                      |                           |                 |                      |                           |run()            |                      v           End of          v                 |               +------+------+   execution /------+-------\         |         End&lt;--\    Dead     /&lt;------------|   Running    |         |               -------+-------             \------+-------/         | Release Block                      ^                           |                 |                      |                           |sleep(), wait()  |                          |      =-------------=      |                 |                      +------|   Blocked   |&lt;-----+                 |                             =------+------=                        |                                    |                               |                                    |                               |                                    +-------------------------------+                         Life cycle of a Thread                      -----------------------------        </code></pre><hr><p>以下是生命周期的各个阶段简述：</p><ul><li><strong>新的（New）</strong> - 新线程在新的状态下开始其生命周期。直到程序启动线程为止，它保持在这种状态。它也被称为<strong>新生线程</strong>。</li><li><strong>可运行的（Runnable）</strong> - 新诞生的线程启动后，该线程可以运行。该状态的线程被认为正在执行其任务。但是，可能还未正式运行，可能在等待资源，如：CPU。</li><li><strong>运行中的（Running）</strong> - 新诞生的线程启动后，如果，所有的准备条件已经满足，该线程会从准备运行状态进入运行状态，执行任务。</li><li><strong>等待（Waiting）</strong> - 有时线程会转换到等待状态，而线程等待另一个线程执行任务。只有当另一个线程发信号通知等待线程才能继续执行时，线程才转回到可运行状态。</li><li><strong>定时等待（Timed Waiting）</strong> - 可运行的线程可以在指定的时间间隔内进入定时等待状态。当该时间间隔到期或发生等待的事件时，此状态的线程将转换回可运行状态。</li><li><strong>终止（Dead）</strong> - 可执行线程在完成任务或以其他方式终止时进入终止状态。</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个线程都有一个优先级，可以帮助操作系统确定安排线程的顺序。</p><p>Java线程优先级在MIN_PRIORITY（常量为1）和MAX_PRIORITY（常量为10）之间的范围内。默认情况下，每个线程都被赋予优先级NORM_PRIORITY（常量为5）。</p><p>具有较高优先级的线程对于一个程序来说更重要，应该在低优先级线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，并且依赖于平台。</p><h2 id="创建自己的第一个线程"><a href="#创建自己的第一个线程" class="headerlink" title="创建自己的第一个线程"></a>创建自己的第一个线程</h2><div class="note success"><h3 id="Java主要可以通过两种方式创建多线程的程序："><a href="#Java主要可以通过两种方式创建多线程的程序：" class="headerlink" title="Java主要可以通过两种方式创建多线程的程序："></a>Java主要可以通过两种方式创建多线程的程序：</h3></div><h4 id="1-通过实现Runnable接口创建一个线程（推荐使用）"><a href="#1-通过实现Runnable接口创建一个线程（推荐使用）" class="headerlink" title="1.通过实现Runnable接口创建一个线程（推荐使用）"></a>1.通过实现Runnable接口创建一个线程（<strong>推荐使用</strong>）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口的方式，创建线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Asion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有Thread的一个引用</span></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个Runnable实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 线程名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RunnableDemo(String name) &#123;</span><br><span class="line">        threadName = name;</span><br><span class="line">        System.out.println(<span class="string">"Creating "</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写run()方法</span></span><br><span class="line"><span class="comment">     * 从100倒数到1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running "</span> + threadName);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread: "</span> + threadName + <span class="string">", "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">" exiting."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通start()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Starting "</span> + threadName);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, threadName);</span><br><span class="line">            <span class="comment">// 真正调用线程类的start()方法，启动线程</span></span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动两个线程测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        RunnableDemo r1 = <span class="keyword">new</span> RunnableDemo(<span class="string">"Thread-1"</span>);</span><br><span class="line">        r1.start();</span><br><span class="line"></span><br><span class="line">        RunnableDemo r2 = <span class="keyword">new</span> RunnableDemo(<span class="string">"Thread-2"</span>);</span><br><span class="line">        r2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过继承Thread类创建一个线程"><a href="#2-通过继承Thread类创建一个线程" class="headerlink" title="2.通过继承Thread类创建一个线程"></a>2.通过继承Thread类创建一个线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承Thread类，创建线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Asion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有Thread的一个引用</span></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    ThreadDemo(String name) &#123;</span><br><span class="line">        threadName = name;</span><br><span class="line">        System.out.println(<span class="string">"Creating "</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写run()方法</span></span><br><span class="line"><span class="comment">     * 从100倒数到1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running "</span> + threadName);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread: "</span> + threadName + <span class="string">", "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">" exiting."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的start()方法</span></span><br><span class="line"><span class="comment">     * 谨慎重写父类的start()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Starting "</span> + threadName);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, threadName);</span><br><span class="line">            <span class="comment">// 真正调用父类的start()方法，启动线程</span></span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动两个线程测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        ThreadDemo t1 = <span class="keyword">new</span> ThreadDemo(<span class="string">"Thread-1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        ThreadDemo t2 = <span class="keyword">new</span> ThreadDemo(<span class="string">"Thread-2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我们来简单分析一下多线程的程序"><a href="#我们来简单分析一下多线程的程序" class="headerlink" title="我们来简单分析一下多线程的程序"></a>我们来简单分析一下多线程的程序</h3><ul><li>首先，我们的RunnableDemo实现的Runnable接口，那必须重写run()方法，run()就是线程running运行的方法，是线程体。</li><li>当new一个Thread实例，传入我们的RunnableDemo实例，这时线程生命周期处在新建（new）阶段；</li><li>然后，当调用Thread实例的start()方法时，说明线程已经准备就绪，转到了就绪（Runnable）状态；</li><li>如果此时，分配到了CPU，调用了run()方法开始执行，就转到运行（Running）状态；</li><li>当run()方法运行结束，线程就结束；或者run()方法中异常导致线程结束退出。</li></ul><p>通过这一小节我们，我们了解java线程的创建和启动。下一节我们来看看java多线程的主要操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-并发透视之初窥探（一）&quot;&gt;&lt;a href=&quot;#Java-并发透视之初窥探（一）&quot; class=&quot;headerlink&quot; title=&quot;Java 并发透视之初窥探（一）&quot;&gt;&lt;/a&gt;Java 并发透视之初窥探（一）&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java" scheme="http://seekheap.com/categories/Java/"/>
    
      <category term="Concurrency" scheme="http://seekheap.com/categories/Java/Concurrency/"/>
    
    
      <category term="Java" scheme="http://seekheap.com/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://seekheap.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>三言两语@Java 数组</title>
    <link href="http://seekheap.com/posts/java/core/java-array-and-memory.html"/>
    <id>http://seekheap.com/posts/java/core/java-array-and-memory.html</id>
    <published>2017-03-21T14:17:16.000Z</published>
    <updated>2018-12-19T09:56:11.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在Java中，数组存储可以存储对象的原始值（int，char，long，…）或引用类型（也可称为指针）。<br>使用“new”创建对象时，会在Heap中分配一个内存空间并返回一个引用。对于数组也是如此，因为数组是Java中的对象。</p><p><strong>1. 单维数组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a1[ ] = new int[3];</span><br><span class="line">int a2[ ] = new int[ ]&#123;3, 6, 7, 4, 9&#125;;</span><br></pre></td></tr></table></figure><p>int [] a1 只是3个整数数组的引用。如果创建一个包含10个整数的数组，则它是相同的 - 分配一个数组并返回一个引用。</p><p><img src="https://upload-images.jianshu.io/upload_images/1753960-8f26e87e538d5758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一维数组内存"></p><p><strong>2. 二维数组</strong></p><p>二维数组怎么样？实际上，我们只能在Java中使用一维数组。二维数组只是一维数组的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[ ][ ] arr = new int[3][ ];</span><br><span class="line">arr[0] = new int[3];</span><br><span class="line">arr[1] = new int[5];</span><br><span class="line">arr[2] = new int[4];</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1753960-992a756d9053264d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二维数组内存情况"></p><p>多维数组与二维数组是同样的道理。</p><p><strong>3. 数组位于Java内存中的哪个位置？</strong></p><p>数组也是Java中的对象，因此对象在内存中如何存储，数组也是一样的形式，只是数组分配了一个连续的内存，用来存储相同类型数据。</p><p>我们知道<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="external">JVM运行时数据区</a>包括：Heap（堆），JVM Stacks（JVM栈），Native Method Stacks（本地方法栈）等。对于如下的简单示例，让我们看看数组与对象及其引用的存储位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">public void m1() &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">m2();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void m2() &#123;</span><br><span class="line">A a2 = new A();</span><br><span class="line">m3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void m3() &#123;</span><br><span class="line">int a3[] = </span><br><span class="line">  new int[]&#123;3, 6, 7, 4, 9&#125;;</span><br><span class="line">m4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void m4() &#123;</span><br><span class="line">A[] a4[] = new A[3];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上面的声明，如果，我们调用 m1() 看看会发生什么：</p><ol><li>当调用m1时，新栈帧（Frame-1）被推入栈，而局部变量i也在Frame-1中创建。</li><li>然后在m1内调用m2，将另一个新栈帧（Frame-2）推入栈。在m2中，在堆中创建类A的对象，并将引用变量放在 Frame-2 帧中。此时，堆栈和堆如下所示：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1753960-53031438316a48fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行到方法 m2 内存情况"></p><ol start="3"><li>方法 m2 继续调用 m3，将另一个新栈帧（Frame-3）push 入栈，方法中，创建了 int[ ] 数组，并将引用 a3 返回放在 Frame-3 帧中。</li><li>方法 m3 继续调用 m4，新栈帧（Frame-3）推入栈，方法 m4 中，创建了存储 A 类型的数组：A[ ] a4 = new A[3]; 数组长度为：3；并将引用 a4 返回放在 Frame-4 帧中。此时，堆栈和堆如下所示：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1753960-739295382dfb5529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法调用内存示意图"></p><p>数组的处理方式与对象相同，因此数组在内存中的位置是没有太大的区别。<br>三言两语，简单的说了一说数组，不知读者是否有所收获，欢迎留言！</p><p>笔者毕竟能力有限，难免有疏漏，如果，大家发现文章有何错误，请不吝赐教。谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;在Java中，数组存储可以存储对象的原始值（int，char，long，…）或引用类型（也可称为指针）。&lt;br&gt;使用“new”创建对象时，会
      
    
    </summary>
    
      <category term="Java" scheme="http://seekheap.com/categories/Java/"/>
    
      <category term="Core" scheme="http://seekheap.com/categories/Java/Core/"/>
    
    
      <category term="Java" scheme="http://seekheap.com/tags/Java/"/>
    
      <category term="Array" scheme="http://seekheap.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Java 架构师知识图谱</title>
    <link href="http://seekheap.com/posts/java/java-leaning-road.html"/>
    <id>http://seekheap.com/posts/java/java-leaning-road.html</id>
    <published>2017-03-21T13:48:57.000Z</published>
    <updated>2018-12-19T10:00:49.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-架构师学习之路-从菜佳娃–-gt-佳娃假购师"><a href="#Java-架构师学习之路-从菜佳娃–-gt-佳娃假购师" class="headerlink" title="Java 架构师学习之路 从菜佳娃–&gt;佳娃假购师 "></a>Java 架构师学习之路 从菜佳娃–&gt;佳娃假购师 </h1><h2 id="分布式架构师知识图谱"><a href="#分布式架构师知识图谱" class="headerlink" title="分布式架构师知识图谱"></a>分布式架构师知识图谱</h2><p><img src="../../assets/img/java/java-leaning-road.svg" alt="java-leaning-road"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-架构师学习之路-从菜佳娃–-gt-佳娃假购师&quot;&gt;&lt;a href=&quot;#Java-架构师学习之路-从菜佳娃–-gt-佳娃假购师&quot; class=&quot;headerlink&quot; title=&quot;Java 架构师学习之路 从菜佳娃–&amp;gt;佳娃假购师 &quot;&gt;&lt;/a&gt;Java
      
    
    </summary>
    
      <category term="Java" scheme="http://seekheap.com/categories/Java/"/>
    
      <category term="Architecture" scheme="http://seekheap.com/categories/Java/Architecture/"/>
    
    
      <category term="Java" scheme="http://seekheap.com/tags/Java/"/>
    
      <category term="Architecture" scheme="http://seekheap.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Git版本控制与Git Flow工作流程</title>
    <link href="http://seekheap.com/posts/scm/git-flow.html"/>
    <id>http://seekheap.com/posts/scm/git-flow.html</id>
    <published>2016-08-26T12:33:25.000Z</published>
    <updated>2018-07-25T11:00:51.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GIT版本控制与工作流程"><a href="#GIT版本控制与工作流程" class="headerlink" title="GIT版本控制与工作流程"></a>GIT版本控制与工作流程</h2><p>修订历史记录</p><blockquote><p>日期：2016-08-26<br>版本：0.1<br>修订人：Asion Lu<br>备注：修订版</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="编写的目的"><a href="#编写的目的" class="headerlink" title="编写的目的"></a>编写的目的</h3><ul><li>通过规范化的流程，使得产品、开发与测试等各个部门更高效的协同工作。</li><li>通过规范化的流程使得产品高效稳定运行。</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在多组员，多项目等环境进行协同工作时，如果没有统一规范、统一流程，则会导致额外的工作量，甚至会做无用功。所以要减少版本冲突，减轻不必要的工作，就需要规范化的工作流程。</p><h2 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h2><ul><li><strong>统一使用Git作为版本控制的主要工具。</strong></li><li><strong>统一使用GitFlow流程管理控制版本。</strong></li></ul><h3 id="提交的准则"><a href="#提交的准则" class="headerlink" title="提交的准则"></a>提交的准则</h3><ol><li><strong>除了源码相关的东西之外，其他build产生的东西（如：maven的target文件夹，.idea文件夹等），均不能提交进入源码仓库，添加到.gitignore文件中忽略掉。</strong></li><li><strong>撰写规范的提交说明。一份好的提交说明可以帮助协作者更轻松更有效地配合工作。</strong></li><li><strong>要严格按照我们指定的流程切换到指定分支，开发相应的功能。</strong></li></ol><h3 id="分支简述"><a href="#分支简述" class="headerlink" title="分支简述"></a>分支简述</h3><p>我们使用的分支流程：<br><img src="../../assets/img/git-flow/01.svg" alt="主要分支"></p><ul><li>天蓝色圆点所在的线为我们源码的主线（master）。</li><li>天蓝色方形指向的节点就是每一个发布版本的标签（tag）。</li><li>紫色圆点所在的线为主要分支线（develop）。</li><li>橙色圆点所在的线为新功能开发分支线（feature）。</li><li>绿色圆点所在的线为<strong>新版本发布</strong>线（release）。</li><li>红色圆点所在的线为发布版本bug修复线（hotfix）。</li></ul><h4 id="主分支说明"><a href="#主分支说明" class="headerlink" title="主分支说明"></a>主分支说明</h4><p>代替原来的单个主线（master），我们使用两个分支来记录源码轨迹：</p><ol><li>原来的master分支用来记录官方发布轨迹；</li><li>新的develop分支是一个集成分支，用来记录开发新功能的轨迹。<br><img src="../../assets/img/git-flow/02.svg" alt="develop"><br>除了master主线和develop主分支线，其他的分支都是临时的分支，有一定的生命周期的，其余的工作流程分支都是围绕这两个分支之间的区别进行的。</li></ol><h4 id="其他分支说明"><a href="#其他分支说明" class="headerlink" title="其他分支说明"></a>其他分支说明</h4><ul><li><strong>新功能分支（Feature Branches）</strong><br>  每一个新的功能都应该创建一个独立的分支，从develop分支中派生出来。当功能完成后，要合并（merged）回develop分支，合并后它的生命周期就结束。新功能分支不会与master分支有直接的交汇。如图：<br><img src="../../assets/img/git-flow/03.svg" alt="feature"><br>  注意：对于所有意图和目的，新功能分支会合并到develop分支。但是，这个Gitflow工作流不会在此结束。</li><li><strong>发布分支（Release Branches）</strong><br>  一旦开发的功能已经满足发布条件（或预定发布日期接近），应该合并所有满足发布条件的新功能分支到develop分支中，然后，开出一个发布分支（Release），开始准备一个发布版本。在这个分支上，不能再添加新的功能，只有bug修复和该版本为导向的任务。一旦到了发布日期，Release就要合并回master发布，并且，打出版本标签。另外，还需要合并回develop分支。<br><img src="../../assets/img/git-flow/04.svg" alt="release"><br>   使用一个专门的分支来准备发布版本，使得一个团队能对当前版本进行抛光，而另一个团队继续为下一个版本的功能做准备。它还创造了良好定义的发展阶段（例如，很容易说，“本周我们正在准备4.0版”，而且真实地看到它在库中的结构）。</li><li><strong>维护分支（Maintenance Branches）</strong><br>  维护分支也就是线上bug修复分支，使用来快速修复生产环境的紧急问题。<br><img src="../../assets/img/git-flow/05.svg" alt="Maintenance"><br>  这个分支是唯一一个开放过程中直接从master分支派生来的分支。快速的修复问题后，它应该被合并回master和develop（或者当前发布分支），然后，master分支需要打一个版本标签。<br>  一个专门的错误修复开发线，可以让团队在不等待下一个发布周期，导致中断工作流程情况下解决问题。可以将维护分支当做主要的问题修复分支，与master并行。</li></ul><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><ul><li><strong>主分支名称：master</strong></li><li><strong>主开发分支名称：develop</strong></li><li><strong>标签（tag）名称：v*.RELEASE，其中”*“ 为版本号，“RELEASE”大写，如：v1.0.0.RELEASE</strong></li><li><strong>新功能开发分支名称：feature-* or feature/*，其中“*” 为新功能简述，如：feature-item-activity-list</strong></li><li><strong>发布分支名称：release-* or release/*，其中* 为版本号，“release”小写，如：release-1.0.0</strong></li><li><strong>master的bug修复分支名称：hotfix-* or hotfix/* ，其中* 为bug简述，如：hotfix/item-update-bug</strong><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2>下面具体演示如何使用工作流来管理版本发布周期。假设我们已经存在或创建了一个源码中央存储仓库。</li></ul><h3 id="工作流的基础"><a href="#工作流的基础" class="headerlink" title="工作流的基础"></a>工作流的基础</h3><p><strong>创建develop分支</strong><br><img src="../../assets/img/git-flow/06.svg" alt="develop"></p><ul><li><p>项目负责人在本地master基础上创建一个develop分支，然后，推送到服务器；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure></li><li><p>其他开发人员，需要克隆develop中央仓库的源码，创建一个develop的轨迹版本；如果，已经克隆过该项目，则，不需要执行以下第一条命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@bitbucket.org:ytx-dev/ytx-demo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure></li></ul><p>develop这个分支将包含项目的完整历史记录，而master将包含缩略版本。<br><strong> 假设开始以下所有的流程之前，都已经创建好develop分支。</strong></p><h3 id="新功能开发流程"><a href="#新功能开发流程" class="headerlink" title="新功能开发流程"></a>新功能开发流程</h3><ol><li><p>新建feature分支<br> <img src="../../assets/img/git-flow/07.svg" alt="feature"><br> 基于develop分支创建新功能分支：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/demo develop</span><br></pre></td></tr></table></figure><p> 推送到远程仓库，共享：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p> <strong>所有开发此新功能的人员，都在此分支上开发提交代码。</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit -m <span class="string">"Add some-file."</span></span><br></pre></td></tr></table></figure></li><li><p>完成新功能开发（合并feature分支到develop）<br> <img src="../../assets/img/git-flow/08.svg" alt="feature"><br> <strong>当确定新功能开发完成，且联调测试通过，并且新功能负责人已经得到合并feature分支到develop分支的允许；这样才能合并feature分支到develop。</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">   git checkout develop</span><br><span class="line">git merge feature/demo</span><br><span class="line">git push</span><br><span class="line">git branch -d feature/demo</span><br></pre></td></tr></table></figure><p> 第一条命令是确保在合并新功能之前，develop分支是最新的。<br> 注意：</p><ul><li><strong>新功能分支，永远不要直接合并到master分支。</strong></li><li><strong>合并可能会有冲突，应该谨慎处理冲突。</strong></li></ul></li><li><p>在测试环境发布develop分支代码（提交测试）</p></li></ol><h3 id="线上版本发布流程"><a href="#线上版本发布流程" class="headerlink" title="线上版本发布流程"></a>线上版本发布流程</h3><ol><li><p>从develop中创建准备发布的release分支<br> <img src="../../assets/img/git-flow/09.svg" alt="develop"><br> 当主测试流程完成，源码已经趋近于稳定状态，应该准备一个发布版本，确立版本号：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-0.1.0 develop</span><br></pre></td></tr></table></figure><p> 推送到远程仓库共享：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p> 这个分支是清理准备发布、 整体回归测试、 更新文档，和做其他任何系统即将发布的事情。</p></li><li>继续抛光改bug</li><li><p>release分支合并到master发布<br> <img src="../../assets/img/git-flow/10.svg" alt="release"><br> 一旦已经满足发布条件（或已经到了预定发布日期），应该把release分支合并到master分支和develop分支中，然后，使用master发布新版本。合并release分支到develop分支是很重要的，要让release上修改的东西能在后续的开发分支中生效。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge release-0.1.0</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>release分支合并到develop</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   git checkout develop</span><br><span class="line">git merge release-0.1.0</span><br><span class="line">git push</span><br><span class="line">git branch -d release-0.1.0</span><br></pre></td></tr></table></figure></li><li><p>打标签<br> Release分支在功能开发分支（develop）和公共发布版（master）中，充当一个缓冲的作用。每当有源码合并到master中的时候，应该在master上打一个标签，以便后续跟踪查阅。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 0.1.0.RELEASE -m <span class="string">"Initial public release"</span> master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure></li></ol><h3 id="线上Bug修复流程"><a href="#线上Bug修复流程" class="headerlink" title="线上Bug修复流程"></a>线上Bug修复流程</h3><p>当终端用户，反馈系统有bug时，为了处理bug，需要从master中创建出保养分支；等到bug修复完成，需要合并回master：</p><ol><li><p>创建hotfix分支</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-<span class="comment">#001 master</span></span><br></pre></td></tr></table></figure></li><li><p>修改bug Fix the bug</p></li><li><p>完成修复，合并到master发布<br> <img src="../../assets/img/git-flow/11.svg" alt="merge"></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>打标签</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 0.1.1.RELEASE -m <span class="string">"Initial public release"</span> master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure></li><li><p>合并到develop</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">git-book</a></li><li><a href="https://www.atlassian.com/git/tutorials/what-is-version-control" target="_blank" rel="external">what-is-version-control</a></li><li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank" rel="external">gitflow-workflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GIT版本控制与工作流程&quot;&gt;&lt;a href=&quot;#GIT版本控制与工作流程&quot; class=&quot;headerlink&quot; title=&quot;GIT版本控制与工作流程&quot;&gt;&lt;/a&gt;GIT版本控制与工作流程&lt;/h2&gt;&lt;p&gt;修订历史记录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日期：
      
    
    </summary>
    
      <category term="VCS" scheme="http://seekheap.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://seekheap.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://seekheap.com/tags/Git/"/>
    
      <category term="Git-flow" scheme="http://seekheap.com/tags/Git-flow/"/>
    
      <category term="VCS" scheme="http://seekheap.com/tags/VCS/"/>
    
      <category term="SCM" scheme="http://seekheap.com/tags/SCM/"/>
    
  </entry>
  
</feed>
